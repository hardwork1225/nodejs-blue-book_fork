<h1 class="article-title no-number">浏览器</h1>

# URL

URL 指的是统一资源定位符，即一个给定的独特资源在 Web 上的地址。

组成部分：

- protocol：协议，表明浏览器必须使用何种协议
- domain：域名，表示正在请求哪个服务器
- port：端口
- path：网络服务器上资源的路径
- parameters：提供给网络服务器的额外参数
- anchor：资源本身的另一部分的锚点，锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向

# BOM

Browser Object Model，浏览器对象模型。

## window 对象

window 对象表示浏览器中打开的窗口。

如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。

### window 对象属性

- pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。

- pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。

- screenLeft，screenTop，screenX，screenY 声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。

  IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。

### window 对象方法

- onload()当页面完全加载到浏览器上时，触发该事件。
- onscroll()当窗口滚动时触发该事件。
- onresize()当窗口大小发生变化时触发该事件。
- setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。
- setTimeout()在指定的毫秒数后调用函数或计算表达式。
- open()打开一个新的浏览器窗口或查找一个已命名的窗口。

## location 对象

window.location 对象：用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。

在编写时可不使用 window 这个前缀。

### location 对象属性

- location.herf = 'url 地址'
- location.hash 返回#号后面的字符串，不包含散列，则返回空字符串。
- location.host 返回服务器名称和端口号
- location.pathname 返回目录和文件名。 /project/test.html
- location.port 返回 URL 中的指定的端口号，如 URL 中不包含端口号返回空字符串
- location.search 返回？号后面的所有值。
- location.portocol 返回页面使用的协议, http:或 https。

### location 对象方法

- href: 设置或获取整个 URL 为字符串。
- reload() ：重新加载页面地址。
- replace(): 重新定向 URL,不会在历史记录中生成新纪录。

## navigator 对象

window.navigator 对象包含有关访问者浏览器的信息。

在编写时可不使用 window 这个前缀。

### navigator 对象属性

- navigator.platform：操作系统类型；
- navigator.userAgent：浏览器设定的 User-Agent 字符串。
- navigator.appName：浏览器名称；
- navigator.appVersion：浏览器版本；
- navigator.language：浏览器设置的语言；
- navigator.userAgent 是最常用的属性，用来完成浏览器判断。

## screen 对象

window.screen 对象包含有关用户屏幕的信息。

### screen 对象方法

- screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏。
- screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏。

## history 对象

window.history 对象包含浏览器的历史。为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。

### history 对象方法

- history.back() - 加载历史列表中的前一个 URL。返回上一页。
- history.forward() - 加载历史列表中的下一个 URL。返回下一页。
- history.go(“参数”) -1 表示上一页，1 表示下一页,或者具体页面的 URL。

# Cookie

HTTP 协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。Cookie 实际上是一小段的文本信息（key-value 格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。

## Cookie 机制

当用户第一次访问并登陆一个网站的时候，cookie 的设置以及发送会经历以下 4 个步骤：

1. 客户端发送一个请求到服务器
2. 服务器发送一个 HttpResponse 响应到客户端，其中包含 Set-Cookie 的头部
3. 客户端保存 cookie，之后向服务器发送请求时，HttpRequest 请求中会包含一个 Cookie 的头部
4. 服务器返回响应数据

![img](assets/13949989-dcf024be2733e725.png)

## Cookie 属性项

| 属性项     | 属性项介绍                                                                     |
| ---------- | ------------------------------------------------------------------------------ |
| NAME=VALUE | 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 |
| Expires    | 过期时间，在设置的某个时间点后该 Cookie 就会失效                               |
| Domain     | 生成该 Cookie 的域名，如 domain="www.baidu.com"                                |
| Path       | 该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/                       |
| Secure     | 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie                     |

打开浏览器控制台，即可查看。

![image-20210412133516255](assets/image-20210412133516255.png)

## Cookie 作用

- 保存用户登录状态：一段时间内免登录。
- 跟踪用户行为：天气预报网站中保存用户上次访问时的地区；有换肤功能的网站保存用户上次访问的界面风格

# Session

Session 代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续的。

Session 是一种服务器端的机制，Session 对象用来存储特定用户会话所需的信息。

Session 由服务端生成，保存在服务器的内存、缓存、硬盘或数据库中。

## Session 实现原理

服务器创建 session 出来后，会把 session 的 id 号，以 cookie 的形式回写给客户端。

只要客户端的浏览器不关，再去访问服务器时，都会带着 session 的 id 号去，服务器发现客户机浏览器带 session id 过来了，就会使用内存中与之对应的 session 为之服务。

## Session 作用

Session 的根本作用就是在服务端存储用户和服务器会话的一些信息。典型的应用有：

- 判断用户是否登录。
- 购物车功能。

> [!note]
>
> **Session 和 Cookie 对比**
>
> 1. **存放位置不同**
>
>    Cookie 保存在客户端。
>
>    Session 保存在服务端。
>
> 2. **数据类型不同**
>
>    Cookie 中只能保管 ASCII 字符串。
>
>    Session 中能够存取任何类型的数据。
>
> 3. **安全性（隐私策略）不同**
>
>    Cookie 存储在浏览器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正 Cookie 中的内容。
>
>    Session 存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。
>
> 4. **有效期不同**
>
>    Cookie 的过期时间属性为一个很大很大的数字，Cookie 就可以在浏览器保存很长时间。
>
>    Session 依赖于名为 JSESSIONID 的 Cookie，而 Cookie JSESSIONID 的过期时间默许为–1，只需关闭了浏览器（一次会话结束），该 Session 就会失效。
>
> 5. **对服务器压力不同**
>
>    Cookie 保管在客户端，不占用服务器资源。
>
>    Session 是保管在服务器端的，每个用户都会产生一个 Session，耗费大量的内存。
>
> 6. **跨域支持上的不同**
>
>    Cookie 支持跨域名访问，例如将 domain 属性设置为“.baidu.com”，则以“.baidu.com”为后缀的一切域名均能够访问该 Cookie。
>
>    Session 则不会支持跨域名访问。Session 仅在他所在的域名内有效。

# 同源策略

Web 允许第一个页面访问第二个页面里的数据，但仅限于两个页面有相同的源（URI、主机和端口号均相同）。这一策略可以组织恶意脚本通过页面的 DOM 对象获得访问另一个敏感信息的权限。

## 同源规则

为了举例，下面的表格给出了与 URL`"http://www.example.com/dir/page.html"`的对比。

| 对比 URL                                                   | 结果   | 结果                       |
| ---------------------------------------------------------- | ------ | -------------------------- |
| `http://www.example.com/dir/page2.html`                    | 同源   | 相同的协议，主机，端口     |
| `http://www.example.com/dir2/other.html`                   | 同源   | 相同的协议，主机，端口     |
| `http://username:password@www.example.com/dir2/other.html` | 同源   | 相同的协议，主机，端口     |
| `http://www.example.com:81/dir/other.html`                 | 不同源 | 相同的协议，主机，端口不同 |
| `https://www.example.com/dir/other.html`                   | 不同源 | 协议不同                   |
| `http://en.example.com/dir/other.html`                     | 不同源 | 不同主机                   |
| `http://example.com/dir/other.html`                        | 不同源 | 不同主机(需要精确匹配)     |
| `http://v2.www.example.com/dir/other.html`                 | 不同源 | 不同主机(需要精确匹配)     |
| `http://www.example.com:80/dir/other.html`                 | 看情况 | 端口明确，依赖浏览器实现   |

> 不像其他浏览器，IE 在计算源的时候没有包括端口。

## 安全考量

**为什么要有同源策略？**

假设这个场景：用户访问银行网站并未关闭，然后去浏览网站 A，网站 A 刚好有脚本访问银行的账号密码，而银行网站是登录状态，则很有可能获取到敏感信息。

## 规避同源策略

同源策略很严格，某些大型网站拥有多个子域名，则会带来问题。

**如何规避同源策略带来的问题呢？**

### document.domain 属性

两个 window 包含的 document.domain 属性可以设置成一样的。比如，orders.example.com 下页面的脚本和 catalog.example.com 下页面的脚本可以设置他们的 document.domain 属性为 example.com。这样就看起来是同源的。

### 跨域资源共享

这种方式使用了一个新的 Origin 请求头和一个新的 Access-Control-Allow-Origin 响应头扩展了 HTTP。

允许**服务端**设置 Access-Control-Allow-Origin 头标识哪些站点可以请求文件，或者设置 Access-Control-Allow-Origin 头为"\*"，允许任意站点访问文件。

浏览器，例如 Firefox3.5，Safari4，IE10 使用这个头允许跨域 HTTP 请求。

### 跨文档通信

在一个 window 对象上调用**postMessage()**会异步的触发 window 上的**onmessage**事件，然后触发定义好的事件处理方法。

### JSONP

JOSNP 允许页面接受另一个域的 JSON 数据，通过在页面增加一个可以从其它域加载带有回调的 JSON 响应的`<script>`标签。

### WebSocket

现代浏览器允许脚本直连一个 WebSocket 地址而不管同源策略。然而，使用 WebSocket URI 的时候，在请求中插入 Origin 头就可以标识脚本请求的源。为了确保跨站安全，WebSocket 服务器必须根据允许接受请求的白名单中的源列表比较头数据。

# 页面加载过程

**浏览器的主要功能**是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置，通过 DNS 查询，将网址转换为 IP 地址。

## 加载

加载是获取资源文件的过程。加载过程中遇到外部 css 文件，浏览器另外发出一个请求，来获取 css 文件。遇到图片资源，浏览器会另外发出一个请求，来获取图片资源。这是异步请求，并不会影响 HTML 文档进行加载。

- DNS 解析

- TCP 连接

- 发送 HTTP 请求

- 服务器处理请求并返回 HTTP 报文

- 浏览器解析渲染页面

- 连接结束

## 解析

HTML 文档解析生成解析树，即 DOM 树，是有 DOM 元素及属性节点组成，树的根是 document 对象。

DOM：文档对象模型的缩写，是 HTML 文档的对象表示，作为 HTML 的外部接口供 JS 调用。

css 解析将 css 文件解析为样式表对象。该对象包含 css 规则，该规则包含选择器和声明对象。

![img](assets/850459-20170220160211382-1802240307.png)

## 渲染

当浏览器获得一个 html 文件时，会`“自上而下”`加载，并在加载过程中进行解析渲染。

# 前端优化

## 常用方法

- 降低请求量：合并资源、减少 HTTP 请求数、gzip 压缩
- 加快请求速度：减少域名数、并行加载、预解析 DNS
- 缓存：HTTP 缓存机制、离线数据缓存 localStorage
- 渲染：使用外部 JS 和 CSS、加载顺序（将 CSS 样式表放在顶部，JS 脚本放在底部）、图片懒加载

## 图片预加载

提前加载图片，当用户需要时可直接从本地缓存中渲染

## 图片延迟加载

访问页面时先把图片替换成一张占位图，当图片出现在浏览器可视区域时，才显示真正的图片内容。

## 按需加载

用户触发了动作时才加载对应的功能。

触发的动作：鼠标点击、键盘输入、鼠标移动、窗口大小更改、拉动滚动条等。

加载的文件：HTML、CSS、JS、图片等。

# 缓存

浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的。

## 缓存过程

浏览器发起请求，服务端进行响应，这是一种**应答模式**。

![image-20210423164146922](assets/image-20210423164146922.png)

由上图可知：

- 浏览器每次发起请求，都会**先在浏览器缓存中查找**该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会**将该结果和缓存标识存入浏览器缓存中**

## 分类

缓存分为两种：强制缓存和协商缓存，根据响应的 header 内容来决定。

| 缓存         | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| ------------ | ------------ | ------------------- | -------------------------------- |
| **强制缓存** | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| **协商缓存** | 从缓存取     | 304（not modified） | 是，通过服务器来告知缓存是否可用 |

### 强制缓存

浏览器发起 HTTP 请求时，如果缓存结果和缓存标识都存在且有效，则直接从浏览器缓存中读取。如果都不存在，发起请求到服务器端。如果只存在缓存标识，但是缓存结果失效，则进入协商缓存。

控制强制缓存的字段是**Expires**和**Cache-Control**，其中**Cache-Control 优先级比 Expires 高**。

- **Expires**

  缓存到期时间。Expires 是 HTTP/1.0 的字段，但是现在浏览器默认使用的是 HTTP/1.1。

- **Cache-Control**

  在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。

  | 指令          | 作用                                         |
  | ------------- | -------------------------------------------- |
  | public        | 客户端和代理服务器都可缓存                   |
  | private       | 只有客户端可以缓存，Cache-Control 的默认取值 |
  | no-cache      | 资源被缓存，但立即失效。下次请求验证是否过期 |
  | no-store      | 资源不缓存                                   |
  | max-age=30    | 缓存在 30 秒后失效                           |
  | max-stable=30 | 30 秒内，即使资源过期，也使用该缓存          |
  | min-fresh=30  | 希望 30 秒内获取新的响应                     |

### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

如果浏览器返回的状态码是 200，则表示资源有更新，需要协商重新请求获取。

如果浏览器返回的状态码是 304，则表示资源无修改，无需更新，可直接从缓存获取。

## 缓存位置

### 内存缓存

内存缓存具有两个特点，分别是**快速读取**和**时效性**。
**快速读取**：内存缓存会将编译解析后的文件，直接存入该进程的内存中，**占据该进程一定的内存资源**，以方便下次运行使用时的快速读取。
**时效性**：缓存时效性很短，会随着进程的释放而释放硬盘缓存

### 硬盘缓存

硬盘缓存则是直接将**缓存写入硬盘**文件中，读取缓存需要对该缓存存放的**硬盘文件进行 I/O 操作**，然后重**新解析该缓存内容**，读取复杂，速度比内存缓存慢。

| 比较     | 读取速度                          | 时效性             | 容量 | 匹配优先级 |
| -------- | --------------------------------- | ------------------ | ---- | ---------- |
| 内存缓存 | 快速                              | 进程关闭，内存清空 | 小   | 先         |
| 硬盘缓存 | 慢，需重新解析文件，进行 I/O 操作 | 时效长             | 大   | 后         |

> [!note]
>
> **浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**
>
> - 对于大文件来说，大概率是不存储在内存中的，反之优先。
> - 当前系统内存**使用率**高的话，文件优先存储进硬盘。
> - JS 脚本和图片解析执行后会存入内存，通过`from memory cache`读取。（JS 文件的使用率较高，随时都可能被执行。）
> - CSS 样式表会存入硬盘，通过`from disk cache`读取。（CSS 样式表只需要加载一次，就可以渲染整个页面，使用率较低。）

## 总结

- **强制缓存**相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。
- **协商缓存**相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match

因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。

![image-20210423153120038](assets/image-20210423153120038.png)

# 状态码

## 301 和 302

- 301 Moved Permanently 永久重定向

  被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

- 302 Moved Temporary 临时重定向

  请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。

> [!note]
>
> 301 比较常用的场景是使用域名跳转。
>
> 302 用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。
