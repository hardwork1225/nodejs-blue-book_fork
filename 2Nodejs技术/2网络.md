<h1 class="article-title no-number">网络 Network</h1>

# 网络模型和协议

## 网络模型

在网络历史的早期，国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)共同出版了开放系统互联的**OSI 七层参考模型**。一台计算机操作系统中的网络过程包括从应用请求(在协议栈的顶部)到网络介质(底部) ，OSI 参考模型把功能分成七个分立的层次。完整的七层通信理论模型，如下图所示。

![img](assets/v2-68c6c874e5e2547bbb0bc23fe572c7a6_1440w.jpg)

发送方由第七层到第一层由上到下按照顺序传送数据，**每个分层在处理上层传递的数据时，附上当前层协议所必须的 “首部”信息**。接收方由第一层到第七层由下到上按照顺序传递数据，每个分层对接收到的数据进行“首部”与“内容”分离，在转发给上一层。最终将发送的数据恢复为原始数据。

然而，实际生产中使用的是**TCP/IP 四层模型**，两者的关系及每层对应的协议如下表所示。

<table>
  <caption>OSI七层模型与TCP/IP四层模型</caption>
  <tr>
    <th>OSI七层模型</th>
    <th>TCP/IP四层模型</th>
    <th>相关协议</th>
    <th>设备应用</th>
  </tr>
  <tr>
    <td>应用层</td>
    <td rowspan="3">应用层</td>
    <td rowspan="3">TCP支持：Telnet、FTP、SMTP、HTTPS、HTTP<br>UDP支持：NFS、SNMP、DNS、TFTP</td>
    <td rowspan="3">应用程序</td>
  </tr>
  <tr>
    <td>表示层</td>
  </tr>
  <tr>
    <td>会话层</td>
  </tr>
  <tr>
    <td>传输层</td>
    <td>传输层</td>
    <td>TCP、UDP</td>
    <td rowspan="2">操作系统</td>
  </tr>
  <tr>
    <td>网络层</td>
    <td>网际层</td>
    <td>IP、ICMP</td>
  </tr>
  <tr>
    <td>数据链路层</td>
    <td rowspan="2">网络接口层</td>
    <td rowspan="2">PPP、Etherent</td>
    <td rowspan="2">驱动程序与网络接口</td>
  </tr>
  <tr>
    <td>物理层</td>
  </tr>
</table>
## SSL协议（传输层）

SSL（Secure Sockets Layer，安全通讯协议），是一个构架于 TCP 之上的安全套接层，是为网络通信提供安全及数据完整性的一种安全协议。

标准化之后的 SSL 名称为 TLS（Transport Layer Security，传输层安全协议）。

## TCP 协议（传输层）

Transmission Control Protocol，传输控制协议。**是一种可靠的，面向连接的协议。**在发送数据前，必须与对方建立连接通道，传输效率低。

> [!note]
>
> **有连接协议**
>
> 发送数据之前，需要在收发主机之间建立一条通信线路，在通信传输前后，专门进行建立和断开连接的处理，如果与对端之间无法通信，可避免发送无谓的数据。
>
> ![img](assets/v2-379891bd70b881ace40430cd4fef4ce6_1440w.jpg)

### TCP 报文首部

![TCP报文首部](assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hZ2ljXzEwMjQ=,size_16,color_FFFFFF,t_70.png)

TCP 报文的首部由 20 个字节固定字节和 4n(n 取[0~5]整数)个可变的选项字节组成，其中固定部分的各字段含义如下：

- 源端口和目的端口：各占 2 个字节，分别写入通信双方进程端口号

- **序号 seq**：占 4 个字节。在 TCP 连接中，传送的字节流中的每一个字节都是要按顺序编号[0~232-1]，整个要传送的字节流的起始序号在必须连接建立时设置，序号字段值代表本报文段所发送的数据的第一个字节的序号

- **确认号 ack**：占 4 个字节，是期望收到对方的下一个报文段的第一个数据字节的序号，即 ack=N,就代表了到序号 N-1 为止的所有数据都被正确接收了。

- 数据偏移：占 4 位，表示 TCP 报文的数据部分起始处距离 TCP 报文首部的起始处有多远，数据偏移值的单位是 32 位字（以 4 字节为计算单位），4 位二进制能表示的值[0~15],这就意味着 TCP 首部最大长度为 60 字节，也就是选项部分的最大长度为 40 字节。

- 保留位：占 6 位，保留为以后使用，目前置为 0

- 控制位：占 6 位，每个控制字段占 1 位，它们的标识和含义是：

- 紧急 URG：URG=1 时，告诉系统此报文中有紧急数据，优先传送，与紧急指针配合使用

- **确认 ACK**：当 ACK=1 时，确认号才有效，ACK=0 时，确认号无效，**TCP 连接建立后，所有报文 ACK 必须都为 1**

- 推送 PSH：发送方把 PSH 置为 1，接收方收到报文后会尽快交付，不用等缓存填满了再交付

- 复位 RST：当 RST=1 时，表明 TCP 连接出现了严重差错，必须释放连接，然后重新建立新运输连接。RST=1 还可以用来拒接一个非法报文段或拒绝打开一个连接。

- **同步 SYN**：为每一个发送的数据包分配一个序列号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则需要在响应报文中使 SYN=1 和 ACK=1

- **终止 FIN**：用来释放一个连接 。当 FIN=1 时，表明此报文段的发送方数据已经发送完毕，并且要求释放运输连接。

- **Window**：占 2 字节，窗口值是[0~216-1]之间的整数。窗口值告诉了对方，从本报文段的确认号算起，允许对方发送的数据量。（接收端告诉发送端自己还有多少缓冲区可以接收数据的，发送端就可以根据接收端的处理能力来发送数据，从而避免接收端处理不过来。）

- 检验和：占 2 字节，用于接收方检验首部和数据部分是否在传输中有差错，类似我们下载文件时的 Md5 签名校验作用。

- 紧急指针：占 2 字节，URG=1 时才起作用，用于指明本报文段中的紧急数据的字节数，紧急数据结束后就是普通数据，所以紧急指针指出了紧急数据的末尾在报文中位置。

- 选项：长度可变，最小 0 字节，最长达 40 字节。首部用来动态存储数据。

### 三次握手建立连接

> [!comment]
>
> **情景模拟**
>
> - [Shake 1] Client：“我给你发了 SYN，你能收到吗？”
> - [Shake 2] Server：“我收到了，回给你 ACK 是 1，你能收到吗？”
> - [Shake 3] Client：“我收到了，现在我可以给你发数据了。”

TCP 建立连接采用的是 C/S 模式，C 指的就是 Client 客户端，S 指的是 Server 服务器。

首先由 Client 发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍)， TCP 规定 SYN=1 时不能携带数据，但要消耗一个序号，因此声明自己的 32 位序号是 seq=x，然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y， ack=x+1， 再然后 Client 再进行一次确认，但不用 SYN 了，这时即为 ACK=1， seq=x+1， ack=y+1。

TCP 连接的过程如下图所示。

![image-20210407131329327](assets/image-20210407131329327.png)

默认情况下客户端 Client 和服务端 Sever 的 TCP 进程都处于**CLOSED**（关闭）状态。
服务端 TCP 服务进程先建立传输控制块 TCB，然后服务端进入**LISTEN**（监听）状态，等待客户端连接请求。

| 握手       | 数据                                     | 描述                                                                                                                                                                                                                                           | 结论                                                |
| ---------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| 第一次握手 | SYN=1<br />seq=x（随机）                 | 客户端 TCP 进程也先建立传输控制块 TCB，然后向服务端发送连接请求报文段，此时 SYN=1,随机选定一个初始序号 seq=x，此报文不能携带数据，但是要消耗掉一个序号，发送完毕后，客户端进入**SYN-SENT**（同步已发送）状态。                                 | Server 确认了 Client 的发送正常，且自己的接受正常。 |
| 第二次握手 | SYN=1<br />ACK=1<br />ack=x+1<br />seq=y | 服务端收到客户端请求连接报文段后，若同意建立连接，则发送确认报文，确认报文中 SYN=1、ACK=1,确认号 ack=x+1,同时随机选定一个自己序号 seq=y,确认报文段同样不能携带数据，但是也要消耗掉一个序号，发送完毕后服务端进入**SYN-RCVD**（同步收到）状态。 | Client 确认了自己和 Server 的发送和接收都正常。     |
| 第三次握手 | ACK=1<br />ack=y+1<br />seq=x+1          | 客户端收到确认报文后，检查 ACK=1，ack=x+1 是否正确，若正确，则向服务端发送确认报文，确认报文中 ACK=1,ack=y+1,seq=x+1,发送后进入**ESTAB-LISHED**状态，服务端收到确认报文后，也进入**ESTAB-LISHED**状态，此时双方 TCP 连接正式建立。             | Server 确认了自己的发送正常。                       |

### 四次挥手终止连接

> [!comment]
>
> **情景模拟**
>
> - [Wave 1] Client：“任务处理完毕，我希望断开连接。”
> - [Wave 2] Server：“哦，是吗？请稍等，我准备一下。”
> - 等待片刻后……
> - [Wave 3] Server：“我准备好了，可以断开连接了。”
> - [Wave 4] Client：“好的，谢谢合作。”

当 Client 没有东西要发送时就要释放 Client 这边的连接，Client 会发送一个报文（没有数据），其中 FIN 设置为 1, Server 收到后会给应用程序一个信，这时 Client 那边的连接已经关闭，即 Client 不再发送信息（但仍可接收信息）。 Client 收到 Server 的确认后进入等待状态，等待 Server 请求释放连接， Server 数据发送完成后就向 Client 请求连接释放，也是用 FIN=1 表示， 并且用 ack = u+1， Client 收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

![image-20210407152114953](assets/image-20210407152114953.png)

> [!note]
>
> - **等待 2MSL**
>
> 关于 TIME_WAIT 过渡到 CLOSED 状态说明： 从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。
>
> - **保活时间**
>
> 另外服务器 B 存在一个保活状态，即如果 A 突然故障死机了，那 B 那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B 会发送探测信息， 以决定是否释放连接。

| 挥手       | 数据                                     | 描述                                                                                                                                      | 结论                                          |
| ---------- | ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| 第一次挥手 | FIN=1<br />seq=u                         | Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。                                                  | Server 知道 Client 关闭连接了                 |
| 第二次挥手 | ACK=1<br />seq=v<br />ack=u+1            | Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。     | Server 回复 Client 收到请求，正在准备关闭连接 |
| 第三次挥手 | FIN=1<br />ACK=1<br />seq=w<br />ack=u+1 | Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。                                                    | Server 准备好了，开始断开连接                 |
| 第四次挥手 | ACK=1<br />seq=u+1<br />ack=w+1          | Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手。 | Client 收到 Server 断开连接                   |

### 滑动/拥塞窗口

#### 滑动窗口

滑动窗口：发送方+接收方

解决发送方和接收方收发数据速率不一致的问题。滑动窗口相当于接收方的缓存，接收方向发送方通知自己可接受数据的大小，而发送方会根据这个数值发送数据

#### 拥塞窗口

拥塞窗口：发送方

控制全局网络的拥塞情况。通过控制发送方每次发送的流量多少，来逐渐试探整体网络的拥塞程度。

如果没有拥塞控制，发送方每次发送的数据大小为滑动窗口，在只有两台主机的时候没有问题，但在现实的网络大环境中，如果每台主机都发送滑动窗口大小的数据，那整个网络系统必然会瘫痪，所以通过在发送方设置拥塞窗口，可以有效缓解网络压力。

### 拥塞控制

慢启动+拥塞避免；快速重传+快速恢复。

- 慢启动：防止一开始速率过快，导致耗尽中间路由器存储空间，从而严重降低 TCP 连接的吞吐量
- 拥塞避免：当拥塞发生时，降低网络传输速率
- 快速重传：在接收到相同 ACK 后，推断出丢失报文段起始序号，然后立即重传此报文
- 快速恢复：在快速重传基础上，如果发生了快速重传，则执行拥塞避免算法而非慢启动

### 知识拓展

#### 1. 三次握手的意义？

三次握手建立可靠的通信通道，使得 Server 和 Client 都能够确保自己的发送和接收功能良好。

第一次握手：CIient 发送给 Server，Server 知道 Client 的发送良好。

第二次握手：Server 回复给 Client，Client 知道自己的发送良好和接收也良好。

第三次握手：CIient 回复给 Server，Server 知道 Client 的接收良好，且自己的接收也良好。

#### 2. 为什么要回传 SYN？

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。SYN 是 TCP/IP 建立连接时使用的握手信号。

#### 3. 传了 SYN 为什么还要传 ACK？

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

> SYN：确认发送方-接收方通道没问题。
>
> ACK：确认接收方-发送方通道没问题。

#### 4. 为什么建立连接是三次握手，关闭连接是四次挥手？

**建立连接**：Server 在 LISTEN 状态下，收到 SYN=1 的建立连接请求后，Server 直接将 ACK 和 SYN 放在一起回复给 Client。

**关闭连接**：Server 在建立连接的状态下，可能此时 Server 正在给 Client 发送数据。这是接收到了 Client 发送来的 FIN=1 的关闭连接请求，此时仅表示 Client 不再发送数据了，而 Server 这边可能数据还没有传输完。所以，Server 先回复告知收到请求。然后 Server 准备关闭连接，当准备好后，再发送一次报文告知 Client。因此，关闭连接需要四次。

#### 5. 如果已经建立了连接，但客户端突然出现故障怎么办？

TCP 设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为 2h，若 2h 之内还没有收到客户端的任何数据，服务器就会发送一个探测报文，之后每隔 75s 发送一次。若连续发送 10 个探测报文仍没有回应，服务器就认为客户端出现故障，接着就关闭连接。

#### 6. 状态机

关于网络连接的建立以及断开, 存在着一个复杂的状态转换机制。

![tcpfsm](assets/tcpfsm.png)

| 状态         | 描述                                                                                                                           |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| CLOSED       | 连接关闭, 所有连接的初始状态                                                                                                   |
| LISTEN       | 监听状态, 等待客户端发送 SYN                                                                                                   |
| SYN-SENT     | 客户端发送了 SYN, 等待服务端回复                                                                                               |
| SYN-RECEIVED | 双方都收到了 SYN, 等待 ACK                                                                                                     |
| ESTABLISHED  | SYN-RECEIVED 收到 ACK 之后, 状态切换为连接已建立                                                                               |
| CLOSE-WAIT   | 被动方收到了关闭请求(FIN)后，发送 ACK，如果有数据要发送，则发送数据，无数据发送则回复 FIN，状态切换到 LAST-ACK                 |
| LAST-ACK     | 等待对方 ACK 当前设备的 CLOSE-WAIT 时发送的 FIN, 等到则切换 CLOSED                                                             |
| FIN-WAIT-1   | 主动方发送 FIN, 等待 ACK                                                                                                       |
| FIN-WAIT-2   | 主动方收到被动方的 ACK, 等待 FIN                                                                                               |
| CLOSING      | 主动方收到了 FIN, 却没收到 FIN-WAIT-1 时发的 ACK, 此时等待那个 ACK                                                             |
| TIME-WAIT    | 主动方收到 FIN, 返回收到对方 FIN 的 ACK, 等待对方是否真的收到了 ACK, 如果过一会又来一个 FIN, 表示对方没收到, 这时要再 ACK 一次 |

## UDP 协议（传输层）

User Datagram Protocol，用户数据报协议。**是一种不可靠的、无连接的协议。**传输效率高，比如我们聊天用的 QQ 就是使用的 UDP 协议。。

UDP 协议是 TCP/IP 的传输层协议的部分，与 TCP 的传输不一样，它提供无连接的、不可靠的传输服务。

> [!note]
>
> **无连接协议**
>
> 无需确认对方是否存在，随时发送数据。
>
> ![img](assets/v2-1537cf5f46541187a14030c8ff0f8a5b_1440w.jpg)

在选择使用协议的时候，选择 UDP 必须要谨慎。在网络质量令人十分不满意的环境下，UDP 协议数据包丢失会比较严重。

但是，由于 UDP 的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

> [!note]
>
> **TCP 和 UDP 的区别**
>
> |              | TCP                   | UDP                      |
> | ------------ | --------------------- | ------------------------ |
> | **连接性**   | 面向连接              | 无连接                   |
> | **双工性**   | 全双工（1:1）         | 一对一 或 一对多         |
> | **可靠性**   | 可靠（重传机制）      | 不可靠（丢包后数据丢失） |
> | **有序性**   | 有序（通过 SYN 排序） | 无序                     |
> | **有界性**   | 无                    | 有消息边界               |
> | **拥塞控制** | 有                    | 无                       |
> | **传输速度** | 慢                    | 快                       |
> | **量级**     | 低                    | 高                       |
> | **头部大小** | 20~60 字节            | 8 字节                   |

## DNS 协议（应用层）

**DNS 是用来将域名转换为 IP 地址。**

当我们可以用 TCP/IP 通信之后，需要向互联网请求资源时，需要获取资源所在服务器的 IP 地址，以进行通信。头疼的是，IP 是 32 位二进制组成，即使点分十进制也很难记忆。

但服务器的主机名很容易记住，比如 `Alan -> 192.168.0.11` 这样只需要记住好记的名字即可，通过一个主机名到 IP 的映射关系，以获取主机服务器对应的 IP 地址。随着这个名字的规范化最终变成了今天的域名（Domain name）。

DNS（域名系统）即保存了互联网上所有域名与 IP 的映射关系，通过主机名获取对应主机 IP 的流程即 DNS 解析流程。

### 域名分级

|          | 示例                     |
| -------- | ------------------------ |
| 顶级域名 | .com、.org、.net、.cn 等 |
| 二级域名 | baidu.com                |
| 三级域名 | zhidao.baidu.com         |

> [!note]
>
> URL 的构成 = http://主机名 . 域名
>
> **www 不是域名的组成部分**，而是主机名，表示该主机提供的是 www 服务（Web 服务）。

## HTTP 协议（应用层）

![img](assets/bg2016081901.jpg)

HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。

**HTTP 协议属于应用层，建立在传输层协议 TCP 之上。**客户端通过与服务器建立 TCP 连接，之后发送 HTTP 请求与接收 HTTP 响应都是通过访问 Socket 接口来调用 TCP 协议实现。

**HTTP 是一种无状态 (stateless) 协议**，HTTP 协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持 HTTP 协议的简单性，从而能够快速处理大量的事务，提高效率。然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。由于`HTTP`是无状态协议，所以必须引入一些技术来记录管理状态，例如`Cookie`。

### HTTP 请求

客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：请求状态行（Request Line）、请求头部（Header）、空行和请求正文（Request Body）四个部分组成。

![image-20210407165917462](assets/image-20210407165917462.png)

下面实例是一点典型的使用 GET 来传递数据的实例：

```sh
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.baidu.com
Accept-Language: en, mi
```

#### 请求状态行

请求状态行有 Method、URI、Version 三部分构成。

- Method：请求方式。常用的有 GET、HEAD、POST、DELETE、PUT。
- URI：请求地址
- Version：遵循的 HTTP 协议版本

例如如下：

```sh
GET /example.html HTTP/1.1 (CRLF)
```

#### 消息头

消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，主要包括：

| Header          | 解释                                                                                                                                                                                                                                                         | 示例                                              |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------- |
| Accept          | 指定客户端能够接收的内容类型                                                                                                                                                                                                                                 | Accept: text/plain, text/html                     |
| Accept-Encoding | 指定浏览器可以支持的 web 服务器返回内容压缩编码类型。                                                                                                                                                                                                        | Accept-Encoding: compress, gzip                   |
| Accept-Language | 浏览器可接受的语言                                                                                                                                                                                                                                           | Accept-Language: en,zh                            |
| Authorization   | HTTP 授权的授权证书                                                                                                                                                                                                                                          | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| Cache-Control   | 指定请求和响应遵循的缓存机制                                                                                                                                                                                                                                 | Cache-Control: no-cache                           |
| Cookie          | HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。                                                                                                                                                                               | Cookie: $Version=1; Skin=new;                     |
| Content-Length  | 请求的内容长度                                                                                                                                                                                                                                               | Content-Length: 348                               |
| Content-Type    | 请求的与实体对应的 MIME 信息，常见的值为：<br />text/plain<br/>text/html<br/>text/css<br/>image/jpeg<br/>image/png<br/>image/svg+xml<br/>audio/mp4<br/>video/mp4<br/>application/javascript<br/>application/pdf<br/>application/zip<br/>application/atom+xml | Content-Type: text/html; charset=utf-8            |
| Host            | 指定请求的服务器的域名和端口号                                                                                                                                                                                                                               | Host: www.baidu.com                               |

### HTTP 响应

当你向对方发送请求后，对方会回应你浏览器的请求，返回两个部分：响应状态行、消息报头，响应正文三部分。

![image-20210407182058918](assets/image-20210407182058918.png)

#### 响应状态行

状态行也由三部分组成，包括 HTTP 协议的版本，状态码，以及对状态码的文本描述。例如：

```sh
HTTP/1.1 200 OK （CRLF）
```

#### 消息头

| Header            | 解释                                               | 示例                                                |
| ----------------- | -------------------------------------------------- | --------------------------------------------------- |
| Accept-Ranges     | 表明服务器是否支持指定范围请求及哪种类型的分段请求 | Accept-Ranges: bytes                                |
| Allow             | 对某网络资源的有效的请求行为，不允许则返回 405     | Allow: GET, HEAD                                    |
| Cache-Control     | 告诉所有的缓存机制是否可以缓存及哪种类型           | Cache-Control: no-cache                             |
| Content-Encoding  | web 服务器支持的返回内容压缩编码类型。             | Content-Encoding: gzip                              |
| Content-Language  | 响应体的语言                                       | Content-Language: en,zh                             |
| Content-Length    | 响应体的长度                                       | Content-Length: 348                                 |
| Content-MD5       | 返回资源的 MD5 校验值                              | Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==               |
| Content-Type      | 返回内容的 MIME 类型                               | Content-Type: text/html; charset=utf-8              |
| Server            | web 服务器软件名称                                 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)        |
| Set-Cookie        | 设置 Http Cookie                                   | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 |
| Transfer-Encoding | 文件传输编码                                       | Transfer-Encoding:chunked                           |
| Warning           | 警告实体可能存在的问题                             | Warning: 199 Miscellaneous warning                  |
| WWW-Authenticate  | 表明客户端请求实体应该使用的授权方案               | WWW-Authenticate: Basic                             |

#### HTTP 状态码

当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。

HTTP 状态码的英文为 HTTP Status Code。 下面是常见的 HTTP 状态码：

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它 URL
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：

| 分类  | 描述                                           |
| ----- | ---------------------------------------------- |
| 1\*\* | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2\*\* | 成功，操作被成功接收并处理                     |
| 3\*\* | 重定向，需要进一步的操作以完成请求             |
| 4\*\* | 客户端错误，请求包含语法错误或无法完成请求     |
| 5\*\* | 服务器错误，服务器在处理请求的过程中发生了错误 |

### HTTP 协议特点

- **支持 C/S 模式。**
- **简单快速**：HTTP 协议简单，请求只需要 Method 和 URI，程序规模小，通信速度快。
- **灵活**：允许传输任意类型的数据。正在传输的类型由`Content-Type`加以标记。
- **无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完请求后，客户端应答后，即断开连接。如果需要长连接，通过`Connection: Keep-Alive`实现。
- **无状态**：无状态指对事务处理没有记忆能力。

### 非持久连接 & 持久连接

**非持久连接**：客户端发送一系列请求，每次请求都经过一个单独的 TCP 连接发送。

**持久连接**：客户端发送一系列请求，每次请求都经过相同的 TCP 连接进行发送。

![image-20210407223155796](assets/image-20210407223155796.png)

> [!note]
>
> 非持久连接在每次请求|响应之后都要断开连接，下次再建立新的 TCP 连接，这样就**造成了大量的通信开销**。**非持久连接给服务器带来了沉重的负担**，每台服务器可能同时面对数以百计甚至更多的请求。
>
> 持久连接就是为了解决这些问题，其特点是一直保持 TCP 连接状态，直到遇到明确的中断要求之后再中断连接。**持久连接减少了通信开销，节省了通信量。**
>
> HTTP 既可以使用非持久连接(nonpersistent connection)，也可以使用持久连接(persistent connection)。HTTP/1.0 使用非持久连接，HTTP/1.1 默认使用持久连接。

## HTTPS 协议（应用层）

### HTTP 的不足

- 通信使用明文(不加密),内容可能会被窃听
- 不验证通信方的身份,因此有可能遭遇伪装
- 无法证明报文的完整性,所以有可能已遭篡改

### HTTPS 协议介绍

HTTP 协议中没有加密机制，但可以通 过和 SSL(Secure Socket Layer， 安全套接层 )或 TLS(Transport Layer Security， 安全层传输协议)的组合使用，加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。**即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。**

**HTTPS（HTTP Secure ）= HTTP + 加密 + 认证 + 完整性保护**

![image-20210407224227789](assets/image-20210407224227789.png)

- **SSL**：Secure Socket Layer，安全套接字层。1994 年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。

- **TLS**：Transport Layer Security，传输层安全。其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999 年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0 和 TLS1.0 由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是 TLS 1.1、TLS 1.2。

HTTPS 采用**共享密钥加密**（对称）和**公开密钥加密**（非对称）两者并用的混合加密机制。

若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。

### HTTPS 设计思路

- 服务器为每个客户端生成公钥。
- 客户端用公钥加密（及时被中间人拦截，中间人也不知道加密算法）。
- 服务器进行私钥解密。

### 中间人攻击

中间人拦截公钥，但是不知道加密算法，也没办法攻击。但是，**中间人可以将服务器发送的公钥包进行掉包**，客户端怎么知道这个公钥是真的服务器发送的还是假的中间人给的非法公钥呢？

![i1dxld0wrm](assets/i1dxld0wrm.png)

为了获取公钥，又要防止黑客攻击，就需要进行 SSL 申购了。

![jl4cw7a1qw](assets/jl4cw7a1qw.png)

> [!note]
>
> 浏览器读取到 SSL 证书中的证书所有者、有效期等信息进行一一校验，并查看内置的 CA 机构，看证书是否真的合法。

### HTTPS 特点

- 所有信息都是加密传播，黑客无法窃听。
- 具有校验机制，一旦被篡改，通信双方会立刻发现。
- 配备身份证书，防止身份被冒充。

## CDN 网络

CDN（Content Delivery Network，内容分发网络）是**构建在现有互联网基础之上的一层智能虚拟网络**，通过在网络各处部署节点服务器，实现将源站内容分发至所有 CDN 节点，使用户可以就近获得所需的内容。

CDN 服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。

### 工作原理

当用户访问使用 CDN 服务的网站时，本地 DNS 服务器通过 CNAME 方式将最终域名请求重定向到 CDN 服务。

CDN 通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的 CDN 节点 IP 地址提供给用户，使用户可以以最快的速度获得网站内容。

使用 CDN 后的 HTTP 请求处理流程如下。

![img](assets/zh-cn_image_0000001129063959.png)

### 应用场景

- 网站加速

  适用于有加速需求的网站，包括门户网站、电商平台、资讯 APP、UGC 应用（User Generated Content，用户原创内容）等，加速各类型图片、html、css、js 小文件等。

- 文件下载加速

  适用于有文件下载业务的网站、下载工具、游戏客户端、APP 商店等，如游戏安装包获取、应用程序包下载、手机 ROM 升级等业务场景。

- 点播加速

  适用于提供音视频点播服务的客户。例如：在线教育类网站、在线视频分享网站、互联网电视点播平台、音乐视频点播 APP 等。

- 全站加速

  适用于各行业动静态内容混合，含较多动态资源请求（如：asp、jsp、php 等格式的文件）的网站。

# Linux 五种网络 IO 模型

前面讲到 Node.js 的特点有两个：**事件驱动**和**异步 IO**。当时，提及“**在 Node.js 中，异步 IO 也称为非阻塞 IO**”。其实，这句话是不准确的，因为在 Linux 系统的网络 IO 模型中，异步 IO 和非阻塞 IO 分别是两种东西。

接下来，我们以 Richard Stevens 的《UNIX® Network Programming》一书为参考，来学习网络模型。该书中，网络模型一共有 5 种：

- **blocking IO**：阻塞 IO。
- **non-blocking IO**：非阻塞 IO。
- **IO multiplexing**：IO 复用。
- **signal driven IO**：信号驱动 IO。
- **asynchronous IO**：异步 IO。

其中，前四个都是同步 IO，最后一个是异步 IO。

IO 其实我们并不陌生，站在操作系统的角度上说，IO 一般指访问磁盘数据，网络 IO 只不过它是读取的不是磁盘，而是 socket。

一般 IO 操作可以分为两步，以 read 操作举例来说：

1. **等待数据准备 (Waiting for the data to be ready)。**

2. **将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。**

由此可见，IO 操作它会涉及到两个系统对象，一个是调用这个 IO 的**进程** (或线程)，另一个就是**系统内核**。

## 阻塞 IO

### 场景描述

我在餐馆点餐，点完后就一直等着菜上来，什么事情也不做。菜上来后，等待结束，继续吃饭或拍照，做其他事情。

### 网络模型

同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在 Linux 中，默认情况下所有的 socket 都是 blocking。它符合人们最常见的思考逻辑。阻塞就是进程 "被" 休息，CPU 处理其它进程去了。

![image-20210406171350636](assets/image-20210406171350636.png)

当用户进程调用了 recv()/recvfrom()这个系统调用，Kernel 就开始了 IO 的第一个阶段：准备数据。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当 Kernel 一直等到数据准备好了，它就会将数据从 Kernel 中拷贝到用户内存，然后 Kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。

## 非阻塞 IO

### 场景描述

我在餐馆点餐，点完后我没有暂停，而是做其他的事情，每隔 1 分钟都来询问服务员菜好了没有。

### 网络模型

同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。

![image-20210406171429556](assets/image-20210406171429556.png)

当用户进程发出 read 操作时，如果 Kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 Kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。

## IO 复用

IO multiplexing 就是我们说的 select，poll，epoll，有些地方也称这种 IO 方式为 event driven IO。

select/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。它的基本原理就是 select，poll，epoll 这个 function 会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。

### 场景描述

去餐厅点餐后，用户需要不断的询问服务员菜是否准备好。现在，IO 复用就是找一个黄牛，黄牛提前告诉服务员我要点的菜菜，然后黄牛来监控菜是否准备好。当菜准备好以后，我直接来告诉让服务员把菜端上来。

### 网络模型

由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的 CPU 时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。

![image-20210406172652931](assets/image-20210406172652931.png)当用户进程调用了 select，那么整个进程会被 block，而同时，Kernel 会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。

IO 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，IO 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。

## 信号驱动 IO

> _该模型不常见，可以忽略。_

该模型允许 socket 进行信号驱动 IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。

![image-20210406174141686](assets/image-20210406174141686.png)

## 异步 IO

相对于同步 IO，异步 IO 不是顺序执行。用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到 socket 数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO 两个阶段，进程都是非阻塞的。

### 场景描述

我在餐厅点餐，点好后我完全不用管，继续做其他的事情。等餐做好了以后，服务员会直接端过来。

### 网络模型

用户进程发起 aio_read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它 read 操作完成了。

![image-20210406180246032](assets/image-20210406180246032.png)

## 总结

**阻塞与非阻塞**：调用 blocking IO 会一直 block 住对应的进程直到操作完成，而 non-blocking IO 在 kernel 还准备数据的情况下会立刻返回。

**同步和异步**：同步和异步主要的区别在于是否存在阻塞。阻塞 IO、非阻塞 IO、IO 复用、信号驱动 IO 都是同步 IO。

各种 IO 模型的比较如图所示。

![image-20210406181746837](assets/image-20210406181746837.png)

# http 模块

Node.js 最强大的功能就是 http 模块了，几行代码就能够搭建起一个 Web Server。

比如，执行下面一行代码，就能够启动一个 Web 服务。

```js
var http = require('http');

// http server 例子
var server = http.createServer(function (serverReq, serverRes) {
  var url = serverReq.url;
  serverRes.end('您访问的地址是：' + url);
});

server.listen(3000);

// http client 例子
var client = http.get('http://127.0.0.1:3000', function (clientRes) {
  clientRes.pipe(process.stdout);
});
```

在上面这个简单的例子里，涉及了 4 个实例。

- **server**：http.Server 实例，用来提供服务，处理客户端的请求。

- **client**：http.ClientReques 实例，用来向服务端发起请求。

- **serverReq**：是 http.IncomingMessage 实例（clientRes 也是，但不常用）。

  serverReq 用来获取客户端请求的相关信息，如 request header。

  clientRes 用来获取服务端返回的相关信息，比如 response header。

- **serverRes**：http.ServerResponse 实例。

## http 属性

### http.METHODS

此属性列出了所有支持的 HTTP 方法。

```js
let methods = require('http').METHODS;
console.log(methods);
/** 输出结果
[ 'ACL',
  'BIND',
  'CHECKOUT',
  'CONNECT',
  'COPY',
  'DELETE',
  'GET',
  'HEAD',
  'LINK',
  'LOCK',
  ...
]
*/
```

### http.STATUS_CODES

此属性列出了所有的 HTTP 状态代码及其描述。

```js
let statusCode = require('http').STATUS_CODES;
console.log(statusCode);
/** 输出结果
{ '100': 'Continue',
  '101': 'Switching Protocols',
  '102': 'Processing',
  '103': 'Early Hints',
  '200': 'OK',
  '201': 'Created',
  '202': 'Accepted',
  ...
}
*/
```

### http.globalAgent

指向 Agent 对象的全局实例，该实例是 `http.Agent` 类的实例。

用于管理 HTTP 客户端连接的持久性和复用，它是 Node.js HTTP 网络的关键组件。

稍后会在 `http.Agent` 类的说明中提供更多描述。

## http 方法

### http.createServer()

返回 `http.Server` 类的新实例。

```js
const server = http.createServer((req, res) => {});
// 等价于
const server = new http.Server((req, res) => {});
```

### http.request()

发送 HTTP 请求到服务器，并创建 `http.ClientRequest` 类的实例。

### http.get()

类似于 `http.request()`，但会自动地设置 HTTP 方法为 GET，并自动地调用 `req.end()`。

## http 类

### http.Agent

Node.js 会创建 `http.Agent` 类的全局实例，以管理 HTTP 客户端连接的持久性和复用，这是 Node.js HTTP 网络的关键组成部分。

该对象会确保对服务器的每个请求进行排队并且单个 socket 被复用。

它还维护一个 socket 池。 出于性能原因，这是关键。

### http.ClientRequest

当 `http.request()` 或 `http.get()` 被调用时，会创建 `http.ClientRequest` 对象。

当响应被接收时，则会使用响应（`http.IncomingMessage` 实例作为参数）来调用 `response` 事件。

返回的响应数据可以通过以下两种方式读取：

- 可以调用 `response.read()` 方法。
- 在 `response` 事件处理函数中，可以为 `data` 事件设置事件监听器，以便可以监听流入的数据。

```js
const http = require('http');
const server = http.createServer((req, res) => {
  res.end('hello, this is from server.');
});
server.listen(3000, () => {
  console.log('服务启动');
});

http.get('http://127.0.0.1:3000', function (res) {
  console.log('=== Client接收到的res响应 ===');
  let result = '';
  res.on('data', (thunk) => {
    // 监听流入的数据
    result += thunk;
  });
  res.on('end', () => {
    // 请求完成，打印输出
    console.log('Client接收到的res响应', result);
  });
});
```

### http.Server

当使用 `http.createServer()` 创建新的服务器时，通常会实例化并返回此类。

拥有服务器对象后，就可以访问其方法：

- `close()` 停止服务器不再接受新的连接。
- `listen()` 启动 HTTP 服务器并监听连接。

```js
const http = require('http');
const requestListener = (req, res) => {
  let body = '';
  // 监听获取POST请求的正文
  req.on('data', function (thunk) {
    body += thunk;
  });
  req.on('end', function () {
    console.log('post body is: ' + body);
    res.end('ok');
  });
};
const server = http.createServer(requestListener);
// const server = new http.Server(requestListener); 跟上面是等价的
server.listen(3000, () => {
  console.log('服务启动');
});
```

#### error 事件

当服务创建出错时，可以通过`error`事件监听到。

```js
const http = require('http');
const requestListener = (req, res) => {
  res.end();
};

const server1 = http.createServer(requestListener);
const server2 = http.createServer(requestListener);

server1.listen(3000);
server2.listen(3000);

server2.on('error', (error) => {
  // server2 的 3000端口被占用，会出错
  // 出错啦！listen EADDRINUSE: address already in use :::3000
  console.error('出错啦！' + error.message);
});
```

#### connect & connection 事件

- connect：当客户端的 HTTP method 为 connect 时触发。
- connection：当 TCP 连接建立时触发。此外，可以通过 req.socket、req.connection 来获取这个 socket。

```js
var http = require('http');
var PORT = 3000;

var server = http.createServer(function (req, res) {
  res.end('ok');
});

// 注意：发起connect请求的例子在 ./httpServerEventConnectClient.js 里
server.on('connect', function (req, socket, head) {
  console.log('connect事件触发'); // 一次都没触发
  socket.end(); // 反正我就只想举个例子，没打算正经处理。。。
});

server.on('connection', function (req, res) {
  console.log('connection事件触发'); // 触发两次
});

server.listen(PORT);
```

### http.ServerResponse

由 `http.Server` 创建，并作为第二个参数传给它触发的 `request` 事件。

通常在代码中用作 `res`：

```js
const server = http.createServer((req, res) => {
  // res 是一个 http.ServerResponse 对象。
  res.end(); // 一定要有
});
```

http 模块四剑客之一的`res`，应该都不陌生了。一个 web 服务程序，接受到来自客户端的 http 请求后，向客户端返回正确的响应内容，这就是`res`的职责。

在事件处理函数中总是会调用的方法是 `end()`，它会关闭响应，当消息完成时则服务器可以将其发送给客户端。 必须在每个响应上调用它。

#### 设置状态码

设置状态代码、状态描述信息，`res`提供了 res.writeHead()、res.statusCode/res.statusMessage 来实现这个目的。

举例，如果想要设置状态码 200，描述信息是’ok‘ ，可以这样写代码：

```js
res.writeHead(200, 'ok');
// 或者
res.statusCode = 200;
res.statusMessage = 'ok';
```

两者差不多，差异点在于

1. res.writeHead() 可以提供额外的功能，比如设置响应头部。

   ```js
   res.writeHead(200, 'ok', {
     'Content-Type': 'text-plain',
   });
   ```

2. 当响应头部发送出去后，res.statusCode/res.statusMessage 会被设置成已发送出去的状态代码/状态描述信息。

#### 设置响应头部

`res`提供了 res.writeHead()、response.setHeader() 来实现响应头部的设置。

举例，比如想把 `Content-Type` 设置为 `text-plain`，那么可以：

```js
// 方法一
res.writeHead(200, 'ok', {
  'Content-Type': 'text-plain',
});

// 方法二
res.setHeader('Content-Type', 'text-plain');
```

两者的差异点在哪里呢？

1. res.writeHead() 不单单是设置 header。

2. 已经通过 res.setHeader() 设置了 header，当通过 res.writeHead() 设置同名 header，res.writeHead() 的设置会覆盖之前的设置。

   ```js
   // 先set，然后wirte，会覆盖
   res.setHeader('Content-Type', 'text/html');
   res.writeHead(200, 'ok', {
     'Content-Type': 'text/plain',
   });

   // 先write，然后set，会报错：Error: Can't set headers after they are sent.
   res.writeHead(200, 'ok', {
     'Content-Type': 'text/plain',
   });
   res.setHeader('Content-Type', 'text/html');
   ```

以下这些方法用于与 HTTP 消息头操作：

- `getHeaderNames()` 获取已设置的 HTTP 消息头名称的列表。
- `getHeaders()` 获取已设置的 HTTP 消息头的副本。
- `setHeader('headername', value)` 设置 HTTP 消息头的值。
- `getHeader('headername')` 获取已设置的 HTTP 消息头。
- `removeHeader('headername')` 删除已设置的 HTTP 消息头。
- `hasHeader('headername')` 如果响应已设置该消息头，则返回 true。
- `headersSent()` 如果消息头已被发送给客户端，则返回 true。

#### 设置响应主体

主要用到 res.write() 以及 res.end() 两个方法。

```js
const http = require('http');

// 访问 http://localhost:3000，会返回 111222333
const server = http.createServer(function (req, res) {
  res.write('111'); // res.write第一次调用，会传header信息进去
  res.write('222'); // res.write可以多次调用
  res.end('333'); // 表示header\body都返回，响应结束
});

server.listen(3000);
```

#### 超时处理

```js
const http = require('http');

const server = http.createServer(function (req, res) {
  res.setTimeout(1000, () => {
    console.error('响应超时');
  });
});

server.listen(3000);
```

### http.IncomingMessage

`http.IncomingMessage` 对象可通过以下方式创建：

- `http.Server`，当监听 `request` 事件时（**服务器端的接接收到的请求**）。
- `http.ClientRequest`，当监听 `response` 事件时（**客户端接收到的响应**）。

它可以用来访问响应：

- 使用 `statusCode` 和 `statusMessage` 方法来访问状态。
- 使用 `headers` 方法或 `rawHeaders` 来访问消息头。
- 使用 `method` 方法来访问 HTTP 方法。
- 使用 `httpVersion` 方法来访问 HTTP 版本。
- 使用 `url` 方法来访问 URL。
- 使用 `socket` 方法来访问底层的 socket。

因为 `http.IncomingMessage` 实现了可读流接口，因此数据可以使用流访问。

```js
const http = require('http');
const server = http.createServer((req, res) => {
  console.log('=== Server接收到的req请求 ===');
  console.log('1、请求URL：', req.url);
  console.log('2、HTTP版本：', req.httpVersion);
  console.log('3、请求方法：', req.method);
  console.log('4、消息头：', req.headers);
  // writeHead 重写响应头
  res.writeHead(201, 'SUCCESS', { 'content-type': 'text/plain' });
  res.end('hello, this is from server.');
});
server.listen(3000, () => {
  console.log('服务启动');
});

http.get('http://127.0.0.1:3000', function (res) {
  console.log('=== Client接收到的res响应 ===');
  console.log('1、HTTP版本：', res.httpVersion);
  console.log('2、返回状态码：', res.statusCode);
  console.log('3、返回状态描述信息：', res.statusMessage);
  console.log('4、返回消息头：', res.headers);
  console.log('5、返回正文：');
  // 在标准输出中查看运行结果
  res.pipe(process.stdout);
});

/** 输出结果

=== Server接收到的req请求 ===
1、请求URL： /
2、HTTP版本： 1.1
3、请求方法： GET
4、消息头： { host: '127.0.0.1:3000', connection: 'close' }

=== Client接收到的res响应 ===
1、HTTP版本： 1.1
2、返回状态码： 201
3、返回状态描述信息： SUCCESS
4、返回消息头： { 'content-type': 'text/plain',
  date: 'Fri, 09 Apr 2021 01:32:49 GMT',
  connection: 'close',
  'transfer-encoding': 'chunked' }
5、返回正文：
hello, this is from server.

*/
```

http.IncomingMessage 的属性/方法/事件 不是特别多，按照是否客户端/服务端 特有的，下面进行简单归类。可以看到：

- **req 特有**：url
- **res 特有**：statusCode、statusMessage

| 类型 | 名称          | 描述                                  | Client 端的 res | Server 端的 req |
| ---- | ------------- | ------------------------------------- | --------------- | --------------- |
| 事件 | aborted       | 当客户端终止请求时，触发 aborted 事件 | ✅              | ✅              |
| 事件 | close         | 当客户端连接断开时，触发 close 事件   | ✅              | ✅              |
| 属性 | headers       | 消息头                                | ✅              | ✅              |
| 属性 | rawHeaders    | 原始消息头                            | ✅              | ✅              |
| 属性 | statusCode    | 状态码                                | ❌              | ✅              |
| 属性 | statusMessage | 状态信息                              | ❌              | ✅              |
| 属性 | httpVersion   | HTTP 版本                             | ✅              | ✅              |
| 属性 | url           | URL 路径                              | ✅              | ❌              |
| 属性 | socket        | 底层 socket 信息                      | ✅              | ✅              |
| 方法 | destroy()     |                                       | ✅              | ✅              |
| 方法 | setTimeout()  | 设置网络连接的超时时间                | ✅              | ✅              |

#### 监听 close & aborted 事件

```js
const http = require('http');

const server = http.createServer(function (req, res) {
  console.log('1、收到客户端请求: ' + req.url);

  req.on('aborted', function () {
    console.log('2、客户端请求aborted');
    res.end();
  });

  req.on('close', function () {
    console.log('3、客户端请求close');
    res.end();
  });

  // res.end('ok'); // 故意不返回，等着客户端中断请求
});

server.listen(3000, function () {
  var client = http.get('http://127.0.0.1:3000');
  setTimeout(function () {
    // 故意延迟1s，确保请求发出，然后销毁请求
    client.destroy();
  }, 1000);
});
```

#### destroy()方法

```js
const http = require('http');

const server = http.createServer(function (req, res) {
  console.log('服务端：收到客户端请求');

  req.destroy(new Error('Server请求终止'));

  req.on('error', function (error) {
    console.log('服务端：req error: ' + error.message);
  });

  req.socket.on('error', function (error) {
    console.log('服务端：req socket error: ' + error.message);
  });
});

server.on('error', function (error) {
  console.log('服务端：server error: ' + error.message);
});

server.listen(3000, function () {
  var client = http.get('http://127.0.0.1:3000/aborted', function (res) {
    setTimeout(() => {
      console.log('Client请求终止');
      res.destroy(new Error('Client请求终止'));
    }, 1000);
  });

  client.on('error', function (error) {
    console.log('客户端：client error触发！' + error.message);
  });
});
```

# https 模块

## Client 端

跟 http 模块的用法非常像，只不过请求的地址是 https 协议的而已，代码如下：

```js
var https = require('https');

https
  .get('https://www.baidu.com', function (res) {
    console.log('status code: ' + res.statusCode);
    console.log('headers: ' + JSON.stringify(res.headers));

    res.on('data', function (data) {
      process.stdout.write(data);
    });
  })
  .on('error', function (err) {
    console.error(err);
  });
```

## Server 端

对外提供 HTTPS 服务，需要有 HTTPS 证书。

```js
var https = require('https');
var fs = require('fs');

var options = {
  key: fs.readFileSync('./cert/key.pem'), // 私钥
  cert: fs.readFileSync('./cert/cert.pem'), // 证书
};

var server = https.createServer(options, function (req, res) {
  res.end('这是来自HTTPS服务器的返回');
});

server.listen(3000);
```

由于我并没有 `www.testhttps.com`这个域名，于是先配置本地 host：`127.0.0.1 www.testhttps.com`。

启动服务，并在浏览器里访问`https://www.chyingp.com:3000`，它会指向我们配置的本机 3000 端口。

注意，浏览器会提示你证书不可靠，点击“信任并继续访问”就行了。

## 访问不受信任网站

当我们通过浏览器，访问 12306 的购票页面 https://kyfw.12306.cn/otn/regist/init 时，chrome 会阻止我们访问，这是因为，12306 的证书是自己颁发的，chrome 无法确认他的安全性。

> _早期 12306 证书自己颁发的，现在 12306 证书已经被 Chrome 信任了_

如果遇到一个不受信任的网站，一般有三种处理方法：

1. 关掉页面，停止访问。（有颜色的网站可以这样操作，但是 12306 这样的重要网站，肯定不行啊！）
2. 无视安全警告，继续访问。
3. 导入网站的根证书，这样浏览器就认为网站证书是受信任的。

https 模块的请求遇到这种情况，也可以配置`rejectUnauthorized`忽略安全警告。

```js
// 例子：忽略安全警告
var https = require('https');

var options = {
  hostname: 'kyfw.12306.cn',
  path: '/otn/leftTicket/init',
  rejectUnauthorized: false, // 忽略安全警告
};

var req = https.get(options, function (res) {
  res.pipe(process.stdout);
});

req.on('error', function (err) {
  console.error(err.code);
});
```

当然，最稳妥的办法，还是**把网站的根证书导入受信任列表**。

# net 模块

net 模块是同样是 Node.js 的核心模块。在 http 模块概览里提到，http.Server 继承了 net.Server，此外，http 客户端与 http 服务端的通信均依赖于 socket（net.Socket）。也就是说，做 node 服务端编程，net 基本是绕不开的一个模块。

net 模块主要用于创建基于流的 TCP 或 IPC 的服务器（`net.createServer()`创建）与客户端连接（`net.createConnection()`创建）。

从组成来看，net 模块主要包含两部分，了解 socket 编程的同学应该比较熟悉了：

- **net.Server**

  此类用于创建 TCP 服务器，内部通过 socket 来实现与客户端的通信。

  可由`net.createServer()`创建。

- **net.Socket**

  此类用于 TCP、本地 socket 的 node 版实现，它实现了全双工的 stream 接口。

  可以由用户创建并且被直接用于与服务器进行交互。 例如，它可由`net.createConnection()`返回，因此用户可以使用它与服务器进行通信。

## Server+Client 例子

```js
const net = require('net');
const PORT = 3000;
const HOST = '127.0.0.1';
// TCP服务端
const server = net.createServer(function (socket) {
  console.log('服务端：收到来自客户端的请求');
  socket.on('data', function (data) {
    console.log('服务端：收到客户端数据，内容为{' + data + '}');
    socket.write('你好，我是服务端'); // 给客户端返回数据
  });
  socket.on('close', function () {
    console.log('服务端：客户端连接断开');
  });
});
server.listen(PORT, HOST, function () {
  console.log('服务端：开始监听来自客户端的请求');
});

// TCP客户端
const client = net.createConnection(PORT, HOST);
client.on('connect', function () {
  console.log('客户端：已经与服务端建立连接');
});
client.end('你好，我是客户端');
client.on('data', function (data) {
  console.log('客户端：收到服务端数据，内容为{' + data + '}');
});
client.on('close', function (data) {
  console.log('客户端：连接断开');
});
```

运行的结果如下：

```
服务端：开始监听来自客户端的请求
服务端：收到来自客户端的请求
客户端：已经与服务端建立连接
服务端：收到客户端数据，内容为{你好，我是客户端}
客户端：收到服务端数据，内容为{你好，我是服务端}
服务端：客户端连接断开
客户端：连接断开
```

## 服务端 net.Server

此类用于创建 TCP 服务器，内部通过 socket 来实现与客户端的通信。可由`net.createServer()`创建。

### server.address()

返回服务端的地址信息，比如绑定的 ip 地址、端口等。

```js
console.log(server.address());
// 输出如下 { port: 3000, family: 'IPv4', address: '127.0.0.1' }
```

### server.close(callback])

关闭服务器，停止接收新的客户端请求。有几点注意事项：

- 对正在处理中的客户端请求，服务器会等待它们处理完（或超时），然后再正式关闭。
- 正常关闭的同时，callback 会被执行，同时会触发 close 事件。
- 异常关闭的同时，callback 也会执行，同时将对应的 error 作为参数传入。（比如还没调用`server.listen(port)`之前，就调用了`server.close()`）

> [!note]
>
> 已调用`server.listen()`：正常关闭，close 事件触发，然后 callback 执行，error 参数为 undefined
>
> 未调用`server.listen()`：异常退出，close 事件触发，然后 callback 执行，error 为具体的错误信息。（注意，error 事件没有触发）

可以看下面两个例子，比较以下正常关闭和异常退出的区别。

**例子 1：服务器正常关闭**

```js
const net = require('net');
const PORT = 3000;
const HOST = '127.0.0.1';
const noop = function () {};

// TCP服务端
const server = net.createServer(noop);

server.listen(PORT, HOST, function () {
  server.close(function (error) {
    if (error) {
      console.log('close回调：服务端异常：' + error.message);
    } else {
      console.log('close回调：服务端正常关闭');
    }
  });
});

server.on('close', function () {
  console.log('close事件：服务端关闭');
});

server.on('error', function (error) {
  console.log('error事件：服务端异常：' + error.message);
});
```

结果输出为：

```
close事件：服务端关闭
close回调：服务端正常关闭
```

**例子 2：服务器异常退出**

```js
const net = require('net');
const noop = function () {};

// TCP服务端
const server = net.createServer(noop);

// 没有正式启动请求监听，会异常退出
// server.listen(PORT, HOST);

server.on('close', function () {
  console.log('close事件：服务端关闭');
});

server.on('error', function (error) {
  console.log('error事件：服务端异常：' + error.message);
});

server.close(function (error) {
  if (error) {
    console.log('close回调：服务端异常：' + error.message);
  } else {
    console.log('close回调：服务端正常关闭');
  }
});
```

结果输出为：

```
close事件：服务端关闭
close回调：服务端异常：Server is not running.
```

### net.Server 的事件

主要有事件 listening、connection、close、error。

- **listening**：调用 server.listen()，正式开始监听请求的时候触发。
- **connection**：当有新的请求进来时触发，参数为请求相关的 socket。
- **close**：服务端关闭的时候触发。
- **error**：服务出错的时候触发，比如监听了已经被占用的端口。

几个事件都比较简单，这里仅举个 **connection** 的例子。

从测试结果可以看出，有新的客户端连接产生时，net.createServer(callback) 中的 callback 回调会被调用，同时 connection 事件注册的回调函数也会被调用。

```js
var net = require('net');
var PORT = 3000;
var HOST = '127.0.0.1';

// tcp服务端
var server = net.createServer(function (socket) {
  // 有新的连接，这个回调会先执行
  socket.write('1. connection 触发\n');
});

server.on('connection', function (socket) {
  // 然后执行connection事件
  socket.end('2. connection 触发\n');
});

server.listen(PORT, HOST);
```

控制台输入`curl http://127.0.0.1:3000`，输出的结果是：

```
1. connection 触发
2. connection 触发
```

## 客户端 net.Socket

此类用于 TCP、本地 socket 的 node 版实现，它实现了全双工的 stream 接口。

可以由用户创建并且被直接用于与服务器进行交互。 例如，它可由`net.createConnection()`返回，因此用户可以使用它与服务器进行通信。

net.Socket 的事件、属性和方法有很多，这里举例常用的，具体可以查看[Node.js 官方文档](http://nodejs.cn/api/net.html#net_class_net_socket)。

```js
const net = require('net');

const PORT = 3000;
const HOST = '127.0.0.1';

// TCP客户端
const client = net.createConnection(PORT, HOST);

client.on('connect', function () {
  console.log('客户端：已经与服务端建立连接');
});

client.on('data', function (data) {
  console.log('客户端：收到服务端数据，内容为{' + data + '}');
});

client.on('close', function (data) {
  console.log('客户端：连接断开');
});

client.end('你好，我是客户端');
```

# dgram 模块

dgram 模块提供了 UDP 用户数据报的 socket 实现。

## UDP 客户端 & 服务端

```js
const dgram = require('dgram');
const PORT = 33333;
const HOST = '127.0.0.1';

// 创建UDP服务端
const server = dgram.createSocket('udp4');
server.on('listening', function () {
  const address = server.address();
  console.log(
    'UDP Server listening on ' + address.address + ':' + address.port
  );
});
server.on('message', function (message, remote) {
  console.log(remote.address + ':' + remote.port + ' - ' + message);
});
server.bind(PORT, HOST);

// 创建UDP客户端
const client = dgram.createSocket('udp4');
const message = Buffer.from('My KungFu is Good!');
client.send(message, PORT, HOST, function (err, bytes) {
  if (err) throw err;
  console.log('UDP message sent to ' + HOST + ':' + PORT);
  client.close();
});
```

输出的结果是：

```
UDP Server listening on 127.0.0.1:33333
UDP message sent to 127.0.0.1:33333
127.0.0.1:51953 - My KungFu is Good!
```

## 广播

通过 dgram 实现广播功能很简单，服务端代码如下。

```js
const dgram = require('dgram');
const port = 33333;

// 创建服务端
const server = dgram.createSocket('udp4');
server.on('message', function (message, rinfo) {
  console.log(
    'server got message: ' +
      message +
      ', from: ' +
      rinfo.address +
      ':' +
      rinfo.port
  );
});
server.bind(port);

// 创建客户端
const client = dgram.createSocket('udp4');
const msg = Buffer.from('hello world');
const host = '255.255.255.255';
client.bind(function () {
  client.setBroadcast(true);
  client.send(msg, port, host, function (err) {
    if (err) throw err;
    console.log('msg has been sent');
    client.close();
  });
});
```

运行程序，最终服务端打印日志如下：

```
msg has been sent
server got message: hello world, from: 192.168.14.170:61516
```

# DNS 模块

**DNS 服务主要基于 UDP**，Node.js 的 DNS 模块用于解析域名。这里只简单介绍两个方法。

### dns.lookup()

```
dns.lookup(hostname[, options], callback)
```

将域名（比如 'runoob.com'）解析为第一条找到的记录 A （IPv4）或 AAAA(IPv6)。

参数 options 可以是一个对象或整数。

如果没有提供 options，IPv4 和 IPv6 地址都可以。

如果 options 是整数，则必须是 4 或 6。

```js
const { lookup, ADDRCONFIG, V4MAPPED } = require('dns');
const options = {
  family: 6,
  hints: ADDRCONFIG | V4MAPPED,
};
lookup('example.com', options, (err, address, family) =>
  console.log(`地址: ${address}, 地址族: IPv${family}`)
);
// 地址: ::ffff:93.184.216.34, 地址族: IPv6

options.all = true; // 当 options.all 为 true 时，则结果将会是一个数组。
lookup('example.com', options, (err, addresses) =>
  console.log(`地址: ${JSON.stringify(addresses)}`)
);
// 地址: [{"address":"::ffff:93.184.216.34","family":6}]
```

### dns.reverse()

```
dns.reverse(ip, callback)
```

反向解析 IP 地址，指向该 IP 地址的域名数组。

### dns.resolve()

```
dns.resolve(hostname[, rrtype], callback)
```

使用 DNS 协议将主机名（例如 `'nodejs.cn'`）解析为一个资源记录的数组。

`callback` 函数的参数为 `(err, records)`。 当成功时， `records` 将会是一个资源记录的数组。

#### rrtypes

以下列出了 dns.resolve() 方法中有效的 rrtypes 值：

- `'A'` IPV4 地址, 默认
- `'AAAA'` IPV6 地址
- `'MX'` 邮件交换记录
- `'TXT'` text 记录
- `'SRV'` SRV 记录
- `'PTR'` 用来反向 IP 查找
- `'NS'` 域名服务器记录
- `'CNAME'` 别名记录
- `'SOA'` 授权记录的初始值

```js
const { resolve } = require('dns');

resolve('www.github.com', 'A', function (err, records) {
  console.log('IPv4 地址:', records);
});

// 输出结果：
// IPv4 地址数组: [ '192.30.255.112' ]
```

# url 模块

URL 字符串是结构化的字符串，包含多个含义不同的组成部分。 解析字符串后返回的 URL 对象，每个属性对应字符串的各个组成部分。

url 模块提供了两套 API 来处理 URL：一个是旧版本传统的 API，一个是实现了 WHATWG 标准的新 API。

**Node.js 从 11 以后，url 模块就被废弃了，改用 URL 类。**

![image-20210409174646052](assets/image-20210409174646052.png)

## url 解析：url.parse()

parse 有三个参数 urlStr、parseQueryString、slashesDenoteHost。

- urlStr：需要解析的 URL。
- parseQueryString：默认为 false，将 query 解析成 object。
- slashesDenoteHost：默认为 false，对`//for/bar`这样的路径进行处理。如果为 true，那么类似`//foo/bar`里的`foo`就会被认为是`hostname`；如果为 false，则`foo`被认为是 pathname 的一部分。

```js
const url = require('url');
const str =
  'http://user:pwd@www.test.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1';

const obj = url.parse(str); // 解析URL
console.log(obj);
```

输出结果：

```js
Url {
  protocol: 'http:',
  slashes: true,
  auth: 'user:pwd',
  host: 'www.test.com:8080',
  port: '8080',
  hostname: 'www.test.com',
  hash: '#part=1',
  search: '?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1',
  query: 'nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1',
  pathname: '/index.html',
  path:
   '/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1',
  href:
   'http://user:pwd@www.test.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'
}
```

我们可以看到，query 参数原封不动没变，我们也可以对参数值进行 decode。只需要这样更改：

```js
const obj = url.parse(str, true); // 解析URL，并把query解析成object
```

然后，输出的结果都不变，只不过 query 变成了对象：

```sh
Url {
  protocol: 'http:',
  slashes: true,
  auth: 'user:pwd',
  host: 'www.test.com:8080',
  port: '8080',
  hostname: 'www.test.com',
  hash: '#part=1',
  search: '?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1',
  query: [Object: null prototype] { nick: '程序猿小卡' },	<<< 变成了对象
  pathname: '/index.html',
  path:
   '/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1',
  href:
   'http://user:pwd@www.test.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1' }
```

## url 拼接：url.format

`url.parse(str)`的反向操作，就像`JSON.parse()`和`JSON.stringify()`的关系。

## url.resolve(from, to)

就像`path.resolve()`的功能，直接贴官方的例子。

```js
url.resolve('/one/two/three', 'four'); // '/one/two/four'
url.resolve('http://example.com/', '/one'); // 'http://example.com/one'
url.resolve('http://example.com/one', '/two'); // 'http://example.com/two'
```

## URL 类

浏览器兼容的 URL 类，根据 WHATWG URL 标准实现。通过`new URL()`实例化一个 URL 对象。

```js
const myURL = new URL(
  'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'
);
console.log(myURL);
```

解析的结果如下：

```sh
URL {
  href:
   'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash',
  origin: 'https://sub.host.com:8080',
  protocol: 'https:',
  username: 'user',
  password: 'pass',
  host: 'sub.host.com:8080',
  hostname: 'sub.host.com',
  port: '8080',
  pathname: '/p/a/t/h',
  search: '?query=string',
  searchParams: URLSearchParams { 'query' => 'string' },
  hash: '#hash'
}
```
